#!/bin/zsh

git_status() {
	export GIT_STATUSLINE=""

	# return if not a git repo
	! git rev-parse --is-inside-work-tree >/dev/null 2>&1 && return

	local line_count() ( wc -l | sed 's/^ *//' )

	# get current branch
	local branch=${$(git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD)#(refs/heads/|tags/)}

	# get current dir
	local git_dir=$(git rev-parse --git-dir 2>/dev/null)

	# symbols
	local -A symbols=(
		[stash]='≡'
		[rebase]='~'
		[origin]='✓'
		[local]='•'
		[diverged]='≠'
		[behind]='↓'
		[ahead]='↑'
		[merge]='!'
		[staged]='+'
		[change]='*'
		[untracked]='?'
	)

	# init statusline & display branch
	local -a statusline=("")

	# merging
	if [[ -n $git_dir ]] && test -r $git_dir/MERGE_HEAD; then
		statusline+="%F{9}${symbols[merge]}$(git --no-pager diff --name-only --diff-filter=U | line_count)%f"
	# rebasing
	elif [[ -n $(git status | grep "rebasing" 2>/dev/null) ]]; then
		statusline+="%F{9}${symbols[rebase]}%f"
	# diverged
	elif [[ -n $(git rev-list HEAD..@{u} 2>/dev/null) ]] && [[ -n $(git rev-list @{u}..HEAD 2>/dev/null) ]]; then
		statusline+="%F{9}${symbols[diverged]}%f"
	# behind
	elif [[ -n $(git rev-list HEAD..@{u} 2>/dev/null) ]]; then
		statusline+="%F{11}${symbols[behind]}$(git rev-list --count HEAD..@{u})%f"
	# ahead
	elif [[ -n $(git rev-list @{u}..HEAD 2>/dev/null) ]]; then
		statusline+="%F{10}${symbols[ahead]}$(git rev-list --count @{u}..HEAD)%f"
	# origin
	elif [[ -n $(git show-ref origin/${branch} 2>/dev/null) ]]; then
		statusline+="%F{10}${symbols[origin]}%f"
	# no upstream
	else
		statusline+="%F{11}${symbols[local]}%f"
	fi

	# branch name
	statusline+="%F{5}${branch}%f"

	# stash
	if [[ -n $(git rev-parse --verify refs/stash 2>/dev/null) ]]; then
		statusline+="${symbols[stash]}$(git stash list | line_count)%f"
	fi

	# staged
	if [[ -n $(git diff --cached 2>/dev/null) ]]; then
		statusline+="%F{10}${symbols[staged]}$(git diff --cached --numstat | line_count)%f"
	fi

	# modified
	if [[ -n $(git diff 2>/dev/null) ]]; then
		statusline+="%F{11}${symbols[change]}$(git diff-files --ignore-submodules --shortstat | sed -E 's/.* ([0-9]+) file.*/\1/')%f"
	fi

	# untracked
	if [[ -n $(git ls-files --others --exclude-standard 2>/dev/null) ]]; then
		statusline+="%F{14}${symbols[untracked]}$(git ls-files --others --exclude-standard | line_count)%f"
	fi

	# set final statusline to global variable
	GIT_STATUSLINE=${(j: :)statusline}
}


precmd() {
	# print a newline before the prompt unless it's the first prompt in the process.
	if [[ -z $newline_before_prompt ]]; then
		newline_before_prompt=1
	elif [[ $newline_before_prompt -eq 1 ]]; then
		echo ''
	fi

	# set tab title to current dir
	print -Pn "\e]0;%1~\a"

	# fetch git info for statusline
	git_status
}

preexec() {
	# set tab title to current dir and process
	print -Pn "\e]0;%1~ ($1)\a"
}

# prompt
PROMPT=$'%F{blue}%~%1(j. (%j).)%f${GIT_STATUSLINE}%f\n%0(?..%F{red})> %f'
